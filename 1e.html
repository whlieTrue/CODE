<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>MUS - EPISODE 1</title>
    <style>
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background: #000;
            font-family: 'Courier New', Courier, monospace;
        }
        #terminal {
            width: 100%; height: 100%; background: #000; color: #0f0;
            padding: 30px; box-sizing: border-box; font-size: 18px;
            line-height: 1.6; overflow-y: auto; position: absolute; top: 0; left: 0; z-index: 100;
        }
        .log-line { margin-bottom: 8px; white-space: pre-wrap; }
        .system-msg { color: #0f0; }
        .narrative-msg { color: #fff; text-shadow: 0 0 5px #fff; }
        #choice-container { margin-top: 30px; display: none; }
        .btn {
            background: transparent; border: 1px solid #0f0; color: #0f0;
            padding: 10px 20px; font-family: inherit; font-size: 18px;
            cursor: pointer; margin-right: 20px; transition: all 0.3s;
        }
        .btn:hover { background: #0f0; color: #000; box-shadow: 0 0 15px #0f0; }
        .glitch { animation: glitch-anim 0.2s infinite; color: #f00 !important; border-color: #f00 !important; }
        @keyframes glitch-anim {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }
        #game-container { display: none; width: 100%; height: 100%; position: relative; }
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 6px; height: 6px; border: 2px solid rgba(255,255,255,0.9);
            border-radius: 50%; transform: translate(-50%, -50%);
            transition: all 0.1s; pointer-events: none;
        }
        #dialogue {
            position: absolute; bottom: 15%; left: 50%;
            transform: translateX(-50%); color: white;
            font-family: 'Courier New', monospace; font-size: 18px;
            background: rgba(0,0,0,0.8); padding: 15px 30px;
            border: 1px solid #ff3333; border-radius: 5px;
            display: none; z-index: 10;
        }
        #game-ui {
            position: absolute; top: 40px; left: 40px;
            color: #ff3333; font-family: 'Courier New', monospace;
            text-shadow: 2px 2px 5px #000; pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="terminal">
        <div id="log"></div>
        <div id="choice-container">
            <button class="btn" onclick="startGame()">[시스템 접속]</button>
            <button id="leave-btn" class="btn" onclick="glitchButton()">[탈출하기]</button>
        </div>
    </div>

    <div id="game-container">
        <div id="game-ui">
            <h1 style="margin:0;">|MUS| EPISOD-1</h1>
            <p id="objective">>>> 목표: 방 안을 조사하고 탈출구를 찾으십시오.</p>
        </div>
        <div id="crosshair"></div>
        <div id="dialogue"></div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        let scene, camera, renderer, controls, raycaster;
        let moveState = { forward: false, backward: false, left: false, right: false };
        let velocity = new THREE.Vector3();
        let prevTime = performance.now();
        let interactableObjects = [];
        let highlightedObject = null;
        const outlineMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.BackSide });

        // --- 터미널 (이전 유지) ---
        window.initSequence = async function() {
            const logArea = document.getElementById('log');
            const terminal = document.getElementById('terminal');
            const bootLogs = ["INITIALIZING SYSTEM...", "LOADING NEURAL NETWORK...", "DECODING SURVIVOR_LOG_#042..."];
            for (let log of bootLogs) {
                const d = document.createElement('div');
                d.className = "log-line system-msg"; d.textContent = `> ${log}`;
                logArea.appendChild(d); await new Promise(r => setTimeout(r, 400));
            }
            const introLines = ["이 세계는 AI의 잘못된 발달로 인한 인간의 멸종이 일어났다.", "난 이 세계를 탈출할 거다."];
            for (let line of introLines) { await typeWriter(line, logArea, terminal); await new Promise(r => setTimeout(r, 800)); }
            document.getElementById('choice-container').style.display = "block";
        }

        function typeWriter(text, area, term) {
            return new Promise(resolve => {
                const div = document.createElement('div'); div.className = "log-line narrative-msg";
                area.appendChild(div); let i = 0;
                function type() { if (i < text.length) { div.textContent += text.charAt(i); i++; term.scrollTop = term.scrollHeight; setTimeout(type, 50); } else { resolve(); } }
                type();
            });
        }

        window.glitchButton = function() {
            const leaveBtn = document.getElementById('leave-btn');
            leaveBtn.classList.add('glitch'); leaveBtn.textContent = "[오류: 접근 불가]";
            setTimeout(() => { leaveBtn.classList.remove('glitch'); leaveBtn.textContent = "[시스템 접속]"; leaveBtn.onclick = startGame; }, 1000);
        }

        // --- 게임 시작 ---
        window.startGame = function() {
            document.getElementById('terminal').style.display = 'none';
            document.getElementById('game-container').style.display = 'block';
            initThreeJS();
            animate();
        }

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x444444);
            scene.fog = new THREE.Fog(0x444444, 1, 15);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('game-container').appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const light = new THREE.PointLight(0xffffff, 30, 15); light.position.set(0, 4, 0); scene.add(light);

            controls = new PointerLockControls(camera, document.body);
            document.addEventListener('click', () => controls.lock());

            // 1. 방 바닥 및 벽 (충돌 판정 시각화용)
            const room = new THREE.Mesh(
                new THREE.BoxGeometry(10, 5, 10), 
                new THREE.MeshStandardMaterial({ color: 0x888888, side: THREE.BackSide })
            );
            scene.add(room);

            // 2. 상호작용 아이템 생성 함수
            function createItem(geo, mat, pos, name, msg) {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos); mesh.name = name; mesh.userData = { message: msg };
                const outline = new THREE.Mesh(geo, outlineMat); outline.scale.multiplyScalar(1.08); outline.position.copy(pos); outline.visible = false;
                mesh.userData.outline = outline; scene.add(mesh, outline);
                interactableObjects.push(mesh);
            }

            // 아이템 배치 (메모, TV)
            createItem(new THREE.BoxGeometry(0.3, 0.02, 0.3), new THREE.MeshStandardMaterial({color: 0xffff00}), new THREE.Vector3(-2, -2.48, -1), "memo", '"밖으로 나가면 안 돼"');
            createItem(new THREE.BoxGeometry(1.6, 1, 0.2), new THREE.MeshStandardMaterial({color: 0x111111}), new THREE.Vector3(0, -1.2, -4.8), "tv", "TV는 죽어있다.");

            // 3. 문 (Door) 생성
            createItem(
                new THREE.BoxGeometry(1.5, 3, 0.1), 
                new THREE.MeshStandardMaterial({color: 0x3d2b1f}), 
                new THREE.Vector3(4.8, -1, 0), 
                "door", 
                "문이 굳게 잠겨있다... 하지만 무언가 일어날 것 같다."
            );

            raycaster = new THREE.Raycaster();
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
        }

        function onKeyDown(e) {
            if(e.code === 'KeyW') moveState.forward = true;
            if(e.code === 'KeyS') moveState.backward = true;
            if(e.code === 'KeyA') moveState.left = true;
            if(e.code === 'KeyD') moveState.right = true;
            if(e.code === 'KeyF' && controls.isLocked) interact();
        }

        function onKeyUp(e) {
            if(e.code === 'KeyW') moveState.forward = false;
            if(e.code === 'KeyS') moveState.backward = false;
            if(e.code === 'KeyA') moveState.left = false;
            if(e.code === 'KeyD') moveState.right = false;
        }

        function interact() {
            if (highlightedObject) {
                const diag = document.getElementById('dialogue');
                diag.innerText = highlightedObject.userData.message;
                diag.style.display = 'block';
                setTimeout(() => diag.style.display = 'none', 3000);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            if (controls && controls.isLocked) {
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                const dirZ = Number(moveState.forward) - Number(moveState.backward);
                const dirX = Number(moveState.right) - Number(moveState.left);
                if (dirZ !== 0) velocity.z -= dirZ * 40.0 * delta;
                if (dirX !== 0) velocity.x -= dirX * 40.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);

                // --- 벽 충돌 판정 (방 경계 제한) ---
                const limit = 4.5; // 방 크기 10의 절반에서 플레이어 두께 제외
                camera.position.x = Math.max(-limit, Math.min(limit, camera.position.x));
                camera.position.z = Math.max(-limit, Math.min(limit, camera.position.z));

                // 하이라이트 체크
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                const hits = raycaster.intersectObjects(interactableObjects);
                if (hits.length > 0 && hits[0].distance < 3) {
                    const target = hits[0].object;
                    if (highlightedObject !== target) {
                        if (highlightedObject) highlightedObject.userData.outline.visible = false;
                        highlightedObject = target;
                        highlightedObject.userData.outline.visible = true;
                        document.getElementById('crosshair').style.borderColor = "#ff3333";
                    }
                } else {
                    if (highlightedObject) {
                        highlightedObject.userData.outline.visible = false;
                        highlightedObject = null;
                        document.getElementById('crosshair').style.borderColor = "rgba(255,255,255,0.9)";
                    }
                }
            }
            renderer.render(scene, camera);
            prevTime = time;
        }

        window.onload = initSequence;
        window.addEventListener('resize', () => {
            if (camera) { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        });
    </script>
</body>
</html>
