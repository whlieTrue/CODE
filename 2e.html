<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>|MUS| EPISOD-1</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #ui {
            position: absolute; top: 40px; left: 40px;
            color: #ff0000; font-family: 'Courier New', monospace;
            letter-spacing: 2px; pointer-events: none;
        }
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 10px; height: 10px; border: 1px solid white;
            border-radius: 50%; transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <div id="ui">
        <h1 style="font-size: 1.5em;">|MUS| EPISOD-1</h1>
        <p>>>> 깨어남... 거울을 확인하라.</p>
    </div>
    <div id="crosshair"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 플레이어 컨트롤러
        const controls = new PointerLockControls(camera, document.body);
        document.addEventListener('click', () => controls.lock());

        // 조명 및 방 (기초)
        scene.add(new THREE.AmbientLight(0x404040, 2));
        const room = new THREE.Mesh(new THREE.BoxGeometry(20, 10, 20), new THREE.MeshStandardMaterial({color: 0x222222, side: THREE.BackSide}));
        scene.add(room);

        // 거울 & 거울 속 나
        const mirror = new THREE.Mesh(new THREE.PlaneGeometry(2, 3), new THREE.MeshBasicMaterial({color: 0x333333}));
        mirror.position.set(0, 2, -9.9);
        scene.add(mirror);

        const mirrorBody = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.8, 0.3), new THREE.MeshStandardMaterial({color: 0x550000}));
        scene.add(mirrorBody);

        // 이동 로직용 변수
        let prevTime = performance.now();
        const moveState = { forward: false, backward: false, left: false, right: false };
        const velocity = new THREE.Vector3();

        document.addEventListener('keydown', (e) => { if(e.code in {KeyW:1, KeyS:1, KeyA:1, KeyD:1}) moveState[e.code === 'KeyW' ? 'forward' : e.code === 'KeyS' ? 'backward' : e.code === 'KeyA' ? 'left' : 'right'] = true; });
        document.addEventListener('keyup', (e) => { if(e.code in {KeyW:1, KeyS:1, KeyA:1, KeyD:1}) moveState[e.code === 'KeyW' ? 'forward' : e.code === 'KeyS' ? 'backward' : e.code === 'KeyA' ? 'left' : 'right'] = false; });

        const history = [];

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            if (controls.isLocked) {
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                if (moveState.forward) velocity.z -= 40.0 * delta;
                if (moveState.backward) velocity.z += 40.0 * delta;
                if (moveState.left) velocity.x -= 40.0 * delta;
                if (moveState.right) velocity.x += 40.0 * delta;
                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
            }

            // 거울 지연 연출
            history.push({ p: camera.position.clone(), r: camera.rotation.clone() });
            if (history.length > 20) {
                const d = history.shift();
                mirrorBody.position.set(d.p.x, d.p.y - 0.5, -9.5); // 거울 앞에 위치
                mirrorBody.rotation.y = d.r.y + Math.PI; // 마주 보는 방향
            }

            renderer.render(scene, camera);
            prevTime = time;
        }
        animate();
    </script>
</body>
</html>
